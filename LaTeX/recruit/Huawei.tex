\documentclass[a4paper]{ctexart}

\usepackage{tabularx} % extra features for tabular environment
\usepackage{amsmath}  % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\usepackage{ctex}
\usepackage{titlesec}
%\usepackage{CJKutf8, CJK}
\usepackage{makecell}                 % 三线表-竖线
\usepackage{booktabs}                 % 三线表-短细横线
% \usepackage{natbib}
\usepackage{graphicx}				  % 表格单元格逆时针
\usepackage{multirow}				  % 合并单元格
\usepackage{array}
\usepackage{amssymb}				  % 勾
\usepackage{amsmath}
\usepackage{longtable}                % 导入 longtable 宏包，表格自动换行
\usepackage{caption}
\usepackage{subcaption}               % 设置子图
\usepackage{caption}
%\usepackage{subfigure}
\usepackage{diagbox}
\usepackage{color}					  % 文本颜色包
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{bbm}					  % 输入指示函数
\usepackage{tablefootnote}			  % 表格注释
\usepackage{pythonhighlight}
%\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tocloft}
\usepackage{authblk}
\usepackage{setspace}
\usepackage{float}
\usepackage[section]{placeins}

% 设置页面边距
\geometry{a4paper, top=1.7cm, bottom=1.6cm, left=1.6cm, right=1.6cm}

%\pagestyle{fancy}
%\fancyhf{}
%\fancyhead{}
%\fancyfoot{}
%\fancyhead[R]{\small Page \thepage\ of \pageref*{LastPage}}
%\fancyhead[L]{\zihao{-5} \songti 开题报告}

\usepackage{listings}                 % 导入代码块
\usepackage{xcolor}

% 定义适合黑色背景的配色方案
\definecolor{vscodeblue}{RGB}{97, 175, 239}  % keywords
\definecolor{vscodegreen}{RGB}{152, 195, 121}% comments
\definecolor{vscodepurple}{RGB}{198, 120, 221}% strings
\definecolor{vscodegray}{RGB}{153,153,153}   % line numbers
\definecolor{vscodeorange}{RGB}{224,108,117} % function names
\definecolor{vscodebackground}{RGB}{40,44,52} % 黑色背景
\definecolor{vscodewhite}{RGB}{248,248,242}  % 白色字体

% 设置 C++ 代码块的样式，适合黑色背景
\lstset{
	language=C++,
	backgroundcolor=\color{vscodebackground},  % 黑色背景
	basicstyle=\ttfamily\footnotesize\color{vscodewhite}, % 白色文字，紧凑的字体大小
	keywordstyle=\color{vscodeblue}\bfseries,  % 关键字颜色
	commentstyle=\color{vscodegreen}\itshape,  % 注释颜色
	stringstyle=\color{vscodepurple},          % 字符串颜色
	numberstyle=\tiny\color{vscodegray},       % 行号颜色
	numbers=left,                              % 行号显示在左侧
	stepnumber=1,                              % 每行都显示行号
	numbersep=5pt,                             % 行号与代码之间的距离
	tabsize=4,                                 % tab 键宽度
	showspaces=false,                          % 不显示空格符号
	showstringspaces=false,                    % 字符串中的空格不显示特殊符号
	breaklines=true,                           % 自动换行
	breakatwhitespace=true,                    % 只在空格处换行
	columns=fullflexible,                      % 紧凑的代码对齐
	keepspaces=true,                           % 保持空格符号
	frame=single,                              % 给代码块加框
	framesep=3pt,                              % 代码与框之间的距离
	rulecolor=\color{vscodegray},              % 框的颜色
	escapeinside={(*@}{@*)},                   % 允许LaTeX注释
	xleftmargin=10pt,                          % 左边距
	xrightmargin=10pt,                         % 右边距
}

\hypersetup{
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=blue,        % color of internal links
	citecolor=blue,        % color of links to bibliography
	filecolor=magenta,     % color of file links
	urlcolor=blue         
}
%++++++++++++++++++++++++++++++++++++++++
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}
\titleformat{\paragraph}[runin]{\normalsize\bfseries}{\paragraph}{1em}{}
\titleformat{\subparagraph}[runin]{\normalsize\bfseries}{\subparagraph}{1em}{}

\begin{document}
	
\section{二叉树消消乐}
	
\begin{center}
	\Large \textbf{二叉树消消乐}
\end{center}
	
\noindent\textbf{时间限制：} 1000MS
	
\noindent\textbf{内存限制：} 256MB
	
\vspace{10pt}
	
\noindent\textbf{题目描述：}
	
给定原始二叉树和参照二叉树(输入的二叉树均为满二叉树，二叉树节点的值范围为[1,1000]，二叉树的深度不超过1000)，现对原始二叉树和参照二叉树中相同层级目值相同的节点进行消除，消除规则为原始二叉树和参照二叉中存在多个值相同的节点只能消除等数量的，消除后的节点变为无效节点，请按节点值出现频率从高到低输出消除后原始二叉树中有效节点的值(如果原始二叉树消除后没有有效节点返回0)。
	
\noindent\textbf{输入描述：}
	
原始二叉树中的节点个数

原始二叉树

参照二叉树中的节点个数

参照二叉树
	
\noindent\textbf{输出描述：} 
	
原始二叉树中有效节点的值，按出现频率从高到低排序(相同频率的值按大小排序)，相同频率的值按降序排列。
	
\noindent\textbf{样例输入1：}
	
\lstset{numbers=none}
\begin{lstlisting}
7
1 3 3 3 4 5 6
3
2 3 4
\end{lstlisting}
\lstset{numbers=left}
	
\noindent\textbf{样例输出1：}
\lstset{numbers=none}
\begin{lstlisting}
36541
\end{lstlisting}
\lstset{numbers=left}
	
\noindent 样例1解释：原始二叉树 A 消除参照二叉树 B 中的重复元素后，有效节点剩余2个3，1个6，1个5，1个4，1个1，3出现的频率2, 6、5、4、1出现的频率为1，按值从大到小排序，所以排序结果为36541。



\noindent\textbf{样例输入2：}
	
\lstset{numbers=none}
\begin{lstlisting}
15
5 6 6 6 7 7 7 8 8 9 9 7 7 5 6
7
5 6 6 7 7 8 8
\end{lstlisting}
\lstset{numbers=left}
	
\noindent\textbf{样例输出2：}
\lstset{numbers=none}
\begin{lstlisting}
79865
\end{lstlisting}
\lstset{numbers=left}
	
\vspace{10pt}
	
\noindent\textbf{思路分析：}

\noindent\textbf{实现代码：}
	
\begin{lstlisting}

\end{lstlisting}
	
\newpage
	
\section{好友推荐系统}
	
\begin{center}
	\Large \textbf{好友推荐系统}
\end{center}
	
\noindent\textbf{时间限制：} 1000MS
	
\noindent\textbf{内存限制：} 256MB
	
\vspace{10pt}
	
\noindent\textbf{题目描述：}
	
你正在为一个社交网络平台开发好友推荐功能。

平台上有N个用户(每个用户使用1到 N的整数编号)，同时系统中维护了用户之间的好友关系。

为了推荐新朋友，平台决定采用“共同好友数量"作为衡量两个用户之间相似度的标准。

系统根据输入用户编号K，输出与此用户K相似度最高的前L个用户ID，来推荐给用户K

\textit{相似度定义:两个用户非好友，两个用户的相似度为拥有的共同好友数(例如用户A和用户B，只有共同好友C和D，相似度=2)}
	
\noindent\textbf{输入描述：}
	
第一行输入一个整数 $n (1 \leq n \leq 100)$，表示物品的数量。
	
第二行输入 $n$ 个整数 $a_1,a_2,\cdots,a_n (a_i \in [1,2])$ 代表物品类别。其中 $a_i = 1$ 表示物品是第一类，$a_i = 2$ 表示物品是第二类。
	
第三行输入 $n$ 个整数 $b_i,b_2,\cdots,b_n (b_i \in [0,1])$ 代表物品是否可被移动，其中 $b_i = 1$ 表示第 $i$ 个物品可以移动，$b_i = 0$ 表示第 $i$ 个物品不可以移动。
	
\noindent\textbf{输出描述：} 
	
在一行上输出一个正整数，表示不美观程度的最小值.
	
\noindent\textbf{样例输入1：}
	
\lstset{numbers=none}
\begin{lstlisting}
6 7 3 2
1 2
1 3
2 3
3 4
3 5
4 5
5 6
\end{lstlisting}
\lstset{numbers=left}
	
\noindent\textbf{样例输出1：}
\lstset{numbers=none}
\begin{lstlisting}
6 0
\end{lstlisting}
\lstset{numbers=left}

\noindent 样例1解释：

输入包含了6个用户，7条好友记录，给用户ID编号为3的用户推荐2个好友。

输出只有编号为6的用户可能是编号3用户的可能好友；

尝试推荐与编号3用户无共同好友的其他用户，由于除编号为6的用户之外，其他用户和编号3用户都是好友，所以找不到陌生人作为推荐的第二个用户：推荐结果不足2个用户，所以推荐的第二个用户编码使用0来占位补足。

\noindent\textbf{样例输入2：}

\lstset{numbers=none}
\begin{lstlisting}
8 11 1 3
1 2
1 3
2 3
3 4
3 5
4 5
5 6
6 7
7 8
1 8
2 7
\end{lstlisting}
\lstset{numbers=left}

\noindent\textbf{样例输出2：}
\lstset{numbers=none}
\begin{lstlisting}
7 4 5
\end{lstlisting}
\lstset{numbers=left}
	
\noindent 样例2解释：

输入包含了8个用户，11条好友记录，给用户ID编号为1的用户推荐3个好友。

按照相似度排序推荐给用户1的相关好友：7 4 5
	
\vspace{10pt}
	
\noindent\textbf{思路分析：}
	
\noindent\textbf{实现代码：}
	
\begin{lstlisting}
#include <iostream>
#include <vector>
#include <set>
#include <unordered_map>
#include <algorithm>
using namespace std;

struct User {
	int id, similarity;
	User(int id, int similarity) : id(id), similarity(similarity) {}
	// 自定义排序规则：相似度高优先，相似度相同时编号小优先
	bool operator<(const User& other) const {
		if (similarity == other.similarity)
		return id < other.id;
		return similarity > other.similarity;
	}
};

int main() {
	int N, M, K, L;
	cin >> N >> M >> K >> L;
	
	
	
	vector<set<int>> friends(N + 1); // 邻接表，存储每个用户的好友列表
	
	// 输入好友关系
	for (int i = 0; i < M; ++i) {
		int X, Y;
		cin >> X >> Y;
		friends[X].insert(Y);
		friends[Y].insert(X);
	}
	
	unordered_map<int, int> similarity; // 用于存储与用户K的相似度
	
	// 遍历K的所有好友，找出与K有共同好友的用户
	if (friends[K].size() > 0) { // 特殊情况2: 如果K没有好友，跳过这一步
		for (int friendOfK : friends[K]) {
			// 计算K的每个好友的好友
			for (int potentialFriend : friends[friendOfK]) {
				// 如果这个用户不是K本身且不是K的好友，则增加相似度
				if (potentialFriend != K && !friends[K].count(potentialFriend)) {
					similarity[potentialFriend]++;
				}
			}
		}
	}
	
	// 将结果放入一个用户结构体数组中
	vector<User> potentialFriends;
	for (int i = 1; i <= N; ++i) {
		if (i != K && !friends[K].count(i)) { // 不是自己且不是好友
			int sim = similarity.count(i) ? similarity[i] : 0;
			potentialFriends.push_back(User(i, sim));
		}
	}
	
	// 对所有潜在好友进行排序
	sort(potentialFriends.begin(), potentialFriends.end());
	
	vector<int> result;
	int recommended = 0;
	
	// 按照相似度高低输出潜在好友
	for (const User& user : potentialFriends) {
		if (recommended < L) {
			result.push_back(user.id);
			recommended++;
		} else {
			break;
		}
	}
	
	// 如果推荐不足L个，补充陌生人（没有与用户K共同好友的非好友）
	for (int i = 1; i <= N && recommended < L; ++i) {
		if (i != K && !friends[K].count(i) && similarity.count(i) == 0) {
			if (find(result.begin(), result.end(), i) == result.end()) { // 避免重复推荐
				result.push_back(i);
				recommended++;
			}
		}
	}
	
	// 如果仍不足L个，补充0
	while (recommended < L) {
		result.push_back(0);
		recommended++;
	}
	
	// 输出结果
	for (int i = 0; i < result.size(); ++i) {
		if (i > 0) cout << " ";
		cout << result[i];
	}
	cout << endl;
	
	return 0;
}
\end{lstlisting}
	
\newpage
	
\section{维修工}
	
\begin{center}
	\Large \textbf{维修工}
\end{center}
	
\noindent\textbf{时间限制：} 1000MS
	
\noindent\textbf{内存限制：} 256MB
	
\vspace{10pt}
	
\noindent\textbf{题目描述：}
	
小红有一棵有 $n$ 个节点的树，其中每个节点是红色或者黑色，她想知道，删除一个红色节点以及与它相连的全部边后，剩余的连通块 \dag 中黑色节点数量的最大值是多少。
	
	\dag：对于树上的两个点，如果它们相互连通，则称他们位于同一个连通块里；显然，在执行删除操作后，剩余部分至多构成两个连通块。
	
	\noindent\textbf{输入描述：}
	
	第一行输入一个整数 $n (1 \leq n \leq 10^5)$ 代表节点的数量。
	
	第二行输入一个长度为 $n$ 的字符串 $s_1,s_2,\cdots,s_n (s_1 \epsilon$ \texttt{{'R','B'})} 代表第 $i$ 个节点的颜色为 $s_i$。若 $s_i$ 为 \texttt{'B'} 表示节点的颜色为黑色，若 $s_i$ 为 \texttt{'R'} 则表示节点的颜色为红色。保证 $s$ 中至少有一个红色节点。
	
	此后 $n-1$ 行，第 $i$ 行输入两个整数 $u_i$ 和 $v_i(1 \leq u_i, v_i \leq n; u_i \neq v_i)$ 表示树上第 $i$ 条边连接节点 $u_i$ 和 $v_i$。
	
	\noindent\textbf{输出描述：} 
	
	在一行上输出一个整数代表最大值。
	
	\noindent\textbf{样例输入1：}
	
	\lstset{numbers=none}
	\begin{lstlisting}
		10
		RRBBBBBBBB
		1 2
		1 3
		1 4
		1 5
		1 7 
		2 8
		4 6
		4 10
		6 9
	\end{lstlisting}
	\lstset{numbers=left}
	
	\noindent\textbf{样例输出1：}
	\lstset{numbers=none}
	\begin{lstlisting}
		7
	\end{lstlisting}
	\lstset{numbers=left}
	
	
	\vspace{10pt}
	
	\noindent\textbf{思路分析：}
	
	\begin{itemize}
		\item[1.] 输入读取与初始化：
		\begin{itemize}
			\item[·] 首先，读取节点的数量 n，再读取每个节点的颜色信息（由 \texttt{'R'} 表示红色，\texttt{'B'} 表示黑色）。
			\item[·] 然后，读取 n-1 条边的信息，并构建无向图，这个图表示的是树的结构。
		\end{itemize}
		
		\item[2.] DFS计算每个子树中的黑色节点数量：
		\begin{itemize}
			\item[·] 利用 DFS（深度优先搜索）从树的根节点开始（这里选择 1 号节点作为根节点），计算每个节点的子树中黑色节点的数量。
			\item[·] \texttt{sub\_black[node]} 记录了以 \texttt{node} 为根节点的子树中黑色节点的数量。如果当前节点是黑色节点，\texttt{sub\_black[node]} 增加 1，否则保持不变。
			\item[·] 对于每个节点的所有相邻节点（子节点），递归地计算其子树中的黑色节点数量并累加到当前节点。
		\end{itemize}
		
		\item[3.] 寻找删除红色节点后黑色节点最多的连通块；
		\begin{itemize}
			\item[·] \texttt{total\_black} 表示整棵树中所有的黑色节点总数。
			\item[·] 对于每一个红色节点，我们检查它的邻居节点。如果邻居节点的子树中的黑色节点数量小于当前红色节点的子树，那么说明这个邻居节点的子树在删除红色节点后将成为独立的连通块，因此可以更新最大黑色连通块。
			\item[·] 如果邻居节点的子树黑色节点数量大于等于当前红色节点的子树，那么我们计算整个树减去红色节点子树后剩余的黑色节点，并更新最大值。
		\end{itemize}
		
		\item[4.] 输出结果。
	\end{itemize}
	
	\noindent\textbf{实现代码：}
	
	\begin{lstlisting}
		#include <iostream>
		#include <vector>
		#include <algorithm>
		
		using namespace std;
		
		const int MAX_N = 100005;  // 最大节点数
		
		vector<int> adj[MAX_N];    // 邻接表表示树的结构
		int sub_black[MAX_N];      // 记录每个节点的子树中黑色节点的数量
		char col[MAX_N];           // 记录每个节点的颜色，'R' 表示红色，'B' 表示黑色
		int n;                     // 节点数
		
		// DFS 计算每个子树中黑色节点的数量
		void dfs(int node, int parent) {
			sub_black[node] = (col[node] == 'B') ? 1 : 0;  // 如果当前节点是黑色，计数+1
			for (int nei : adj[node]) {  // 遍历相邻节点
				if (nei != parent) {     // 避免回到父节点，防止死循环
					dfs(nei, node);      // 递归处理子节点
					sub_black[node] += sub_black[nei];  // 累加子树中的黑色节点数量
				}
			}
		}
		
		int main() {
			cin >> n;  // 输入节点数
			string colors;
			cin >> colors;  // 输入每个节点的颜色信息
			
			// 将颜色信息存入 col 数组中，节点编号从1开始
			for (int i = 0; i < n; ++i) {
				col[i + 1] = colors[i]; 
			}
			
			// 读取树的边信息，构建无向图
			for (int i = 1; i < n; ++i) {
				int u, v;
				cin >> u >> v;
				adj[u].push_back(v);
				adj[v].push_back(u);
			}
			
			// 计算以每个节点为根的子树中黑色节点的数量
			dfs(1, -1);  // 从节点1开始，父节点设为-1（表示无父节点）
			
			int total_black = sub_black[1];  // 整棵树中黑色节点的总数
			int max_black_comp = 0;  // 记录删除某个红色节点后最大的黑色连通块的数量
			
			// 遍历所有节点，找出红色节点
			for (int i = 1; i <= n; ++i) {
				if (col[i] == 'R') {  // 只有红色节点需要考虑删除的情况
					for (int nei : adj[i]) {  // 遍历该红色节点的所有邻居节点
						if (sub_black[nei] < sub_black[i]) {
							// 邻居节点的子树形成一个独立的黑色连通块
							max_black_comp = max(max_black_comp, sub_black[nei]);
						} else {
							// 其他部分形成一个连通块
							max_black_comp = max(max_black_comp, total_black - sub_black[i]);
						}
					}
				}
			}
			
			// 输出删除红色节点后最大黑色连通块的数量
			cout << max_black_comp << endl;
			
			return 0;
		}
		
	\end{lstlisting}
	
	
\end{document}